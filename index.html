<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>NeoTherion Neural Core Master</title>
<script src="https://unpkg.com/dexie/dist/dexie.js"></script>
<script src="https://unpkg.com/compromise"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>
:root {
--bg: #0a0a0c; 
--panel: #121216; 
--accent: #ff3e3e;
--accent-glow: rgba(255, 62, 62, 0.4);
--neo: #ffaa00;
--text: #d1d1d1;
--subtext: #8b949e;
--user-msg: #1a1a20; 
--bot-msg: #0d0d10; 
--border: #2d1b1b;
--err: #f85149;
--dream: #8b949e; 
--success: #800000; 
--warning: #d1d1d1;
--btn-h: 52px;
--beast-gradient: linear-gradient(135deg, #ff3e3e 0%, #800000 100%);
--glass: rgba(18, 18, 22, 0.8);
}
* { 
box-sizing: border-box; 
-webkit-tap-highlight-color: transparent; 
scrollbar-width: thin;
scrollbar-color: var(--accent) var(--bg);
}
::-webkit-scrollbar { 
width: 6px; 
}
::-webkit-scrollbar-track { 
background: var(--bg); 
}
::-webkit-scrollbar-thumb { 
background: var(--accent); 
border-radius: 10px; 
border: 1px solid var(--bg);
}
body { 
margin: 0; 
background: var(--bg); 
color: var(--text); 
font-family: 'Segoe UI', 'JetBrains Mono', Roboto, Helvetica, sans-serif;
height: 100dvh; 
display: flex; 
flex-direction: column; 
overflow: hidden;
background-image: radial-gradient(circle at 50% 50%, rgba(20, 10, 10, 1) 0%, rgba(5, 5, 7, 1) 100%);
}
#system-loader {
position: fixed; 
top: 0; 
left: 0; 
width: 100%; 
height: 100%;
background: var(--bg); 
z-index: 10000;
display: flex; 
flex-direction: column; 
align-items: center; 
justify-content: center;
transition: opacity 1.2s cubic-bezier(0.4, 0, 0.2, 1);
}
.loader-content { 
text-align: center; 
}
.neotherion-ring {
width: 80px; 
height: 80px; 
border: 2px solid var(--border);
border-top: 2px solid var(--accent); 
border-radius: 50%;
animation: spin 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) infinite; 
margin: 0 auto 24px;
box-shadow: 0 0 20px var(--accent-glow);
}
@keyframes spin { 
0% { transform: rotate(0deg); } 
100% { transform: rotate(360deg); } 
}
.loader-text { 
font-family: 'Courier New', monospace; 
color: var(--accent); 
font-size: 11px; 
letter-spacing: 4px; 
text-transform: uppercase;
text-shadow: 0 0 8px var(--accent-glow);
}
header { 
padding: 16px 24px; 
border-bottom: 2px solid var(--border); 
background: var(--panel); 
display: flex; 
justify-content: space-between; 
align-items: center; 
z-index: 30; 
flex-wrap: wrap; 
gap: 12px;
box-shadow: 0 4px 20px rgba(0,0,0,0.5);
}
.brand {
font-size: 1.2rem;
letter-spacing: 2px;
font-weight: 900;
color: var(--text);
}
.brand span {
color: var(--accent);
text-shadow: 0 0 10px var(--accent-glow);
}
.status-chip { 
padding: 6px 14px; 
border-radius: 4px; 
background: rgba(255, 62, 62, 0.05); 
color: var(--accent); 
border: 1px solid var(--accent); 
font-size: 10px; 
font-weight: bold; 
text-transform: uppercase; 
letter-spacing: 1px;
}
.confidence-indicator { 
font-size: 9px; 
color: var(--subtext); 
margin-left: 10px; 
font-family: monospace; 
}
.preload-status { 
font-size: 10px; 
color: var(--warning); 
padding: 4px 10px; 
border-radius: 4px; 
background: rgba(210, 153, 34, 0.05); 
border: 1px solid var(--warning); 
animation: pulse-border 2s infinite; 
}
@keyframes pulse-border { 
0% { opacity: 0.5; } 
50% { opacity: 1; } 
100% { opacity: 0.5; } 
}
.message-hidden { 
display: none !important; 
}
.toggle-history-btn { 
background: transparent; 
border: 1px solid var(--border); 
color: var(--subtext); 
font-size: 9px; 
padding: 5px 10px; 
border-radius: 4px; 
cursor: pointer; 
margin-left: 12px;
transition: all 0.2s;
text-transform: uppercase;
}
.toggle-history-btn:hover { 
color: var(--accent); 
border-color: var(--accent); 
background: rgba(255,62,62,0.05); 
}
#chat-window { 
flex: 1; 
overflow-y: auto; 
padding: 30px 20px; 
display: flex; 
flex-direction: column; 
gap: 24px; 
scroll-behavior: smooth; 
}
.typing-bubble {
align-self: flex-start; 
background: var(--bot-msg); 
border: 1px solid var(--border);
padding: 12px 18px; 
border-radius: 2px 18px 18px 18px;
display: flex; 
gap: 6px; 
align-items: center; 
margin-bottom: 10px;
}
.typing-dot { 
width: 5px; 
height: 5px; 
background: var(--accent); 
border-radius: 50%; 
opacity: 0.4; 
animation: typing-pulse 1s infinite; 
}
.typing-dot:nth-child(2) { 
animation-delay: 0.2s; 
}
.typing-dot:nth-child(3) { 
animation-delay: 0.4s; 
}
@keyframes typing-pulse { 
0%, 100% { opacity: 0.3; transform: scale(0.8); } 
50% { opacity: 1; transform: scale(1.2); } 
}
.bubble { 
padding: 14px 18px; 
border-radius: 18px; 
max-width: 80%; 
font-size: 15px; 
line-height: 1.6; 
position: relative; 
animation: bubbleAppear 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
word-wrap: break-word;
box-shadow: 0 2px 15px rgba(0,0,0,0.2);
}
.bubble code { 
background: #000; 
padding: 2px 4px; 
border-radius: 4px; 
font-family: monospace; 
color: var(--neo); 
}
.bubble pre { 
background: #000; 
padding: 10px; 
border-radius: 8px; 
overflow-x: auto; 
border: 1px solid var(--border); 
margin: 10px 0; 
}
.bubble blockquote { 
border-left: 4px solid var(--accent); 
margin: 10px 0; 
padding-left: 15px; 
color: var(--subtext); 
}
.bubble table { 
border-collapse: collapse; 
width: 100%; 
margin: 10px 0; 
font-size: 13px; 
}
.bubble th, .bubble td { 
border: 1px solid var(--border); 
padding: 8px; 
text-align: left; 
}
.bubble th { 
background: rgba(255,62,62,0.1); 
}
@keyframes bubbleAppear { 
from { opacity: 0; transform: translateY(15px) scale(0.95); } 
to { opacity: 1; transform: translateY(0) scale(1); } 
}
.user { 
align-self: flex-end; 
background: var(--beast-gradient); 
color: white; 
border-radius: 18px 18px 2px 18px;
font-weight: 400;
}
.bot { 
align-self: flex-start; 
background: var(--bot-msg); 
border: 1px solid var(--border); 
border-radius: 2px 18px 18px 18px; 
border-left: 3px solid var(--accent);
}
.state-tag { 
font-size: 9px; 
position: absolute; 
top: -20px; 
left: 0; 
color: var(--accent); 
text-transform: uppercase; 
font-weight: 800; 
letter-spacing: 1.5px;
}
.confidence-badge { 
position: absolute; 
top: -20px; 
right: 0; 
font-size: 8px; 
padding: 2px 6px; 
border-radius: 4px; 
background: rgba(255,255,255,0.03); 
color: var(--subtext);
border: 1px solid var(--border);
}
.state-transition { 
font-size: 9px; 
color: var(--warning); 
margin-top: 8px; 
opacity: 0.8; 
font-style: italic;
padding-top: 8px;
border-top: 1px solid rgba(255,255,255,0.05);
}
.bubble.bot[data-state="Dreaming"] { 
border-color: var(--dream); 
background: rgba(163, 113, 247, 0.03); 
border-left-color: var(--dream);
}
.bubble.bot[data-state="Dreaming"] .state-tag { 
color: var(--dream); 
}
.teach-prompt { 
align-self: center; 
padding: 15px 20px; 
border-radius: 8px; 
background: rgba(163, 113, 247, 0.05); 
border: 1px dashed var(--dream); 
font-size: 12px; 
margin: 10px 0; 
text-align: center;
color: var(--dream);
}
.teach-prompt button { 
background: var(--success); 
color: var(--dream); 
border: none; 
padding: 8px 16px; 
border-radius: 4px; 
font-size: 11px; 
font-weight: bold; 
margin-left: 10px; 
cursor: pointer; 
text-transform: uppercase;
transition: transform 0.2s;
}
.teach-prompt button:active { 
transform: scale(0.9); 
}
.date-separator {
align-self: center; 
font-size: 10px; 
color: var(--subtext); 
background: var(--bg);
padding: 5px 15px; 
border-radius: 20px; 
border: 1px solid var(--border);
margin: 20px 0; 
opacity: 0.6; 
letter-spacing: 2px; 
text-transform: uppercase;
}
.dock { 
padding: 20px; 
background: var(--panel); 
border-top: 1px solid var(--border); 
position: relative; 
z-index: 40;
box-shadow: 0 -10px 30px rgba(0,0,0,0.3);
}
.input-row { 
display: flex; 
gap: 12px; 
align-items: flex-end; 
}
#user-input { 
flex: 1; 
min-height: var(--btn-h); 
max-height: 150px; 
padding: 14px 18px; 
background: #000; 
color: white; 
border: 1px solid var(--border); 
border-radius: 8px; 
font-size: 15px; 
resize: none; 
outline: none; 
transition: border-color 0.3s;
line-height: 1.4;
}
#user-input:focus { 
border-color: var(--accent); 
box-shadow: 0 0 10px rgba(255, 62, 62, 0.1); 
}
#send-btn { 
height: var(--btn-h); 
width: var(--btn-h); 
background: var(--beast-gradient); 
color: white; 
border: none; 
border-radius: 8px; 
font-weight: bold; 
font-size: 20px; 
cursor: pointer; 
display: flex; 
align-items: center; 
justify-content: center; 
transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
}
#send-btn:hover { 
filter: brightness(1.2); 
box-shadow: 0 0 15px var(--accent-glow); 
}
#send-btn:active { 
transform: scale(0.9); 
}
.btn { 
height: var(--btn-h); 
width: 100%; 
margin-top: 10px; 
background: var(--accent); 
color: white; 
border: none; 
border-radius: 8px; 
font-weight: 800; 
font-size: 13px; 
text-transform: uppercase;
letter-spacing: 1.5px;
display: flex; 
align-items: center; 
justify-content: center; 
cursor: pointer; 
transition: 0.3s; 
}
.btn:hover { 
background: #ff5555; 
}
.btn:active { 
transform: scale(0.98); 
}
.btn:disabled { 
opacity: 0.3; 
cursor: not-allowed; 
filter: grayscale(1); 
}
.btn-outline { 
background: transparent; 
color: var(--accent); 
border: 1px solid var(--accent); 
}
.btn-outline:hover { 
background: rgba(255, 62, 62, 0.1); 
}
.btn-danger { 
background: var(--err); 
color: white; 
}
#lab { 
position: fixed; 
bottom: 130px; 
left: 15px; 
right: 15px; 
height: 75dvh; 
background: var(--panel); 
border: 1px solid var(--border); 
border-top: 4px solid var(--accent); 
border-radius: 12px 12px 0 0; 
display: none; 
flex-direction: column; 
z-index: 50; 
box-shadow: 0 -20px 60px rgba(0,0,0,0.9); 
overflow: hidden;
animation: labSlideUp 0.4s cubic-bezier(0.23, 1, 0.32, 1);
}
@keyframes labSlideUp { 
from { transform: translateY(100%); } 
to { transform: translateY(0); } 
}
.lab-tabs { 
display: flex; 
background: #0a0a0c; 
border-bottom: 1px solid var(--border); 
}
.tab-btn { 
flex: 1; 
height: 50px; 
background: none; 
border: none; 
color: var(--subtext); 
font-size: 11px; 
text-transform: uppercase; 
font-weight: 800; 
letter-spacing: 1px; 
opacity: 0.6; 
cursor: pointer; 
transition: 0.3s; 
}
.tab-btn:hover { 
opacity: 1; 
color: var(--text); 
}
.tab-btn.active { 
opacity: 1; 
border-bottom: 3px solid var(--accent); 
color: var(--accent); 
background: rgba(255,62,62,0.03); 
}
.tab-content { 
flex: 1; 
overflow-y: auto; 
padding: 20px; 
display: none; 
}
.tab-content.active { 
display: block; 
}
.card { 
background: #0d0d10; 
padding: 20px; 
border-radius: 8px; 
border: 1px solid var(--border); 
margin-bottom: 20px; 
}
.field-label { 
font-size: 10px; 
color: var(--accent); 
margin-bottom: 10px; 
display: block; 
text-transform: uppercase; 
letter-spacing: 2px; 
font-weight: 900; 
}
.hint { 
font-size: 10px; 
color: var(--neo); 
margin-bottom: 12px; 
display: block; 
line-height: 1.5; 
opacity: 0.8; 
border-left: 2px solid var(--border); 
padding-left: 10px; 
}
.multi-line { 
width: 100%; 
padding: 14px; 
background: #000; 
border: 1px solid var(--border); 
color: white; 
border-radius: 6px; 
font-size: 14px; 
margin-bottom: 12px; 
line-height: 1.5; 
outline: none; 
resize: none; 
}
.multi-line:focus { 
border-color: var(--neo); 
}
.checkbox-grid { 
display: flex; 
flex-direction: column; 
gap: 8px; 
margin-bottom: 15px; 
max-height: 250px; 
overflow-y: auto; 
border: 1px solid var(--border); 
border-radius: 6px; 
padding: 10px; 
background: #050507; 
}
.check-item { 
background: #0d0d10; 
padding: 10px 14px; 
border-radius: 6px; 
border: 1px solid var(--border); 
display: flex; 
align-items: center; 
gap: 12px; 
font-size: 13px; 
cursor: pointer; 
transition: 0.2s; 
}
.check-item:hover { 
background: #1a1a20; 
border-color: var(--accent); 
}
.check-item.sub { 
margin-left: 25px; 
border-style: dashed; 
opacity: 0.4; 
pointer-events: none; 
}
.check-item.sub.active { 
opacity: 1; 
pointer-events: auto; 
}
.response-item .multi-line { 
margin: 0; 
flex: 1; 
height: 65px; 
min-height: 45px; 
font-size: 13px; 
}
.weight-input { 
width: 55px; 
background: #1a1a20; 
border: 1px solid var(--border); 
color: var(--accent); 
border-radius: 4px; 
padding: 4px; 
font-size: 11px; 
text-align: center; 
margin-left: auto; 
font-family: monospace;
}
.response-item .weight-input { 
margin-left: 10px; 
margin-top: 10px; 
}
select.input-field { 
width: 100%; 
padding: 12px; 
background: #000; 
color: white; 
border: 1px solid var(--border); 
border-radius: 6px; 
margin-bottom: 15px; 
cursor: pointer; 
font-size: 13px; 
}
.state-item { 
display: flex; 
justify-content: space-between; 
align-items: center; 
padding: 10px 14px; 
background: rgba(255,255,255,0.02); 
border-radius: 6px; 
margin-bottom: 8px; 
border: 1px solid transparent; 
}
.state-item:hover { 
border-color: var(--border); 
}
.state-item.sub-item { 
margin-left: 25px; 
border-left: 2px solid var(--accent); 
border-radius: 0 6px 6px 0; 
background: rgba(255, 62, 62, 0.02); 
}
.toggle-row { 
display: flex; 
justify-content: space-between; 
align-items: center; 
margin-bottom: 12px; 
}
.switch { 
position: relative; 
display: inline-block; 
width: 44px; 
height: 24px; 
}
.switch input { 
opacity: 0; 
width: 0; 
height: 0; 
}
.slider-toggle { 
position: absolute; 
cursor: pointer; 
top: 0; 
left: 0; 
right: 0; 
bottom: 0; 
background-color: #2d1b1b; 
transition: .4s; 
border-radius: 34px; 
border: 1px solid var(--border); 
}
.slider-toggle:before { 
position: absolute; 
content: ""; 
height: 16px; 
width: 16px; 
left: 3px; 
bottom: 3px; 
background-color: #555; 
transition: .4s; 
border-radius: 50%; 
}
input:checked + .slider-toggle { 
background-color: var(--accent); 
border-color: var(--accent); 
}
input:checked + .slider-toggle:before { 
transform: translateX(20px); 
background-color: white; 
box-shadow: 0 0 10px white; 
}
.range-wrap { 
margin: 15px 0; 
}
input[type=range] { 
-webkit-appearance: none; 
width: 100%; 
background: transparent; 
}
input[type=range]:focus { 
outline: none; 
}
input[type=range]::-webkit-slider-runnable-track { 
width: 100%; 
height: 4px; 
cursor: pointer; 
background: var(--border); 
border-radius: 2px; 
}
input[type=range]::-webkit-slider-thumb { 
height: 18px; 
width: 18px; 
border-radius: 50%; 
background: var(--accent); 
cursor: pointer; 
-webkit-appearance: none; 
margin-top: -7px; 
box-shadow: 0 0 10px var(--accent-glow); 
}
.debug-panel { 
font-family: 'JetBrains Mono', 'Courier New', monospace; 
font-size: 10px; 
background: #000; 
padding: 12px; 
border-radius: 6px; 
margin-top: 10px; 
max-height: 180px; 
overflow-y: auto; 
border: 1px solid var(--border); 
}
.debug-line { 
padding: 3px 0; 
opacity: 0.7; 
border-bottom: 1px solid rgba(255,255,255,0.03); 
color: #00ff00;
}
.debug-line.fail {
color: #ff3e3e;
}
.debug-line.path {
color: #ffaa00;
}
.preview-box { 
background: #050507; 
border: 1px solid var(--border); 
border-radius: 6px; 
padding: 15px; 
margin-top: 10px; 
font-size: 13px; 
line-height: 1.6; 
min-height: 50px; 
color: var(--text); 
border-left: 3px solid var(--neo); 
}
.preview-label { 
font-size: 9px; 
color: var(--neo); 
margin-bottom: 6px; 
text-transform: uppercase; 
font-weight: 800; 
letter-spacing: 1px; 
}
.rule-list { 
max-height: 450px; 
overflow-y: auto; 
}
.rule-card { 
background: #050507; 
border: 1px solid var(--border); 
border-radius: 6px; 
padding: 15px; 
margin-bottom: 12px; 
transition: 0.2s; 
}
.rule-card:hover { 
border-color: var(--accent); 
}
.rule-header { 
display: flex; 
justify-content: space-between; 
align-items: center; 
margin-bottom: 10px; 
padding-bottom: 8px; 
border-bottom: 1px solid var(--border); 
}
.rule-id { 
color: var(--accent); 
font-weight: 900; 
font-size: 11px; 
font-family: monospace; 
letter-spacing: 1px; 
}
.rule-actions { 
display: flex; 
gap: 8px; 
}
.rule-action-btn { 
background: #1a1a20; 
border: 1px solid var(--border); 
color: var(--text); 
font-size: 12px; 
cursor: pointer; 
padding: 4px 10px; 
border-radius: 4px; 
transition: 0.2s; 
}
.rule-action-btn:hover { 
border-color: var(--accent); 
color: var(--accent); 
}
.rule-action-btn.delete { 
color: var(--err); 
}
.rule-action-btn.delete:hover { 
background: var(--err); 
color: white; 
}
.rule-detail { 
font-size: 11px; 
color: var(--subtext); 
margin: 6px 0; 
line-height: 1.4; 
}
.rule-detail strong { 
color: var(--text); 
font-size: 10px; 
text-transform: uppercase; 
margin-right: 5px; 
opacity: 0.8; 
}
</style>
</head>
<body>
<div id="system-loader">
<div class="loader-content">
<div class="neotherion-ring"></div>
<div class="loader-text" id="loader-msg">AWAKENING THE BEAST...</div>
</div>
</div>
<header>
<div class="brand">
NEO <span>THERION</span>
<span class="confidence-indicator" id="last-confidence"></span>
<button class="toggle-history-btn" onclick="toggleMessageVisibility()">üëÅ HISTORY</button>
</div>
<div id="preload-status" class="preload-status" style="display:none;"></div>
<div id="mode-display" class="status-chip">INITIALIZING</div>
</header>
<main id="chat-window"></main>
<div class="dock">
<div class="input-row">
<textarea id="user-input" placeholder="Enter command or whisper..."></textarea>
<button id="send-btn">‚û§</button>
</div>
<button id="toggle-lab-btn" class="btn btn-outline" onclick="toggleLab()">‚öô SYSTEM ARCHITECT CENTER</button>
</div>
<section id="lab">
<nav class="lab-tabs">
<button class="tab-btn active" onclick="switchTab(event, 'tab-train')">Core Training</button>
<button class="tab-btn" onclick="switchTab(event, 'tab-rules')">Rule Library</button>
<button class="tab-btn" onclick="switchTab(event, 'tab-states')">Architect</button>
<button class="tab-btn" onclick="switchTab(event, 'tab-debug')">Debug</button>
</nav>
<div id="tab-train" class="tab-content active">
<div class="card" style="border-left: 4px solid var(--accent);">
<span class="field-label">1. Neural Response Logic</span>
<span class="hint">Define output variants. Use weights to control randomness. Supports Markdown.</span>
<div id="response-grid" class="checkbox-grid"></div>
<button onclick="addResponseItem()" class="btn btn-outline" style="margin-top:8px; height:42px;">+ ADD RESPONSE VARIANT</button>
<div class="preview-label">REAL-TIME INJECTION PREVIEW:</div>
<div id="response-preview" class="preview-box">Awaiting neural input...</div>
<span class="field-label">2. Prompt Chaining</span>
<span class="hint">Auto-send this message to the system after this rule fires.</span>
<input type="text" id="train-chain" class="multi-line" style="height:45px;" placeholder="e.g. check status">
<span class="field-label">3. Destination States</span>
<span class="hint">Select states to transition into upon successful match.</span>
<div id="next-state-grid" class="checkbox-grid"></div>
<span class="field-label">4. Activation Triggers</span>
<span class="hint">Prefix '+' for relational follow-ups. Use [capture] for variable extraction.</span>
<textarea id="train-trigger" class="multi-line" placeholder="Enter trigger patterns..."></textarea>
<span class="field-label">5. Contextual Filter</span>
<span class="hint">Only activate this rule if NeoTherion is currently in these states.</span>
<div id="filter-state-grid" class="checkbox-grid"></div>
<button id="save-rule-btn" onclick="saveTraining()" class="btn">COMMIT NEURAL RULE</button>
</div>
<div class="card">
<span class="field-label">Mass Data ingestion</span>
<textarea id="bulk-input" class="multi-line" placeholder="Paste JSON datasets or legacy logs..."></textarea>
<button onclick="parseUniversal()" class="btn btn-outline">PROCESS STREAM</button>
</div>
</div>
<div id="tab-rules" class="tab-content">
<div class="card">
<span class="field-label">Active Rule Library (<span id="rule-count">0</span>)</span>
<div id="rule-list" class="rule-list"></div>
</div>
</div>
<div id="tab-states" class="tab-content">
<div class="card">
<div class="toggle-row">
<span class="field-label" style="margin:0; color:var(--err);">Executive Script Permission</span>
<label class="switch">
<input type="checkbox" id="script-exec-toggle" onchange="toggleScriptExecution()">
<span class="slider-toggle" style="opacity: 0.8;"></span>
</label>
</div>
<span class="hint">‚ö† DANGER: Enabling this allows the engine to execute &lt;script&gt; tags within bot responses.</span>
</div>
<div class="card">
<div class="toggle-row">
<span class="field-label" style="margin:0;">Vector Threading (Optimization)</span>
<label class="switch">
<input type="checkbox" id="vector-threading-toggle" onchange="toggleVectorThreading()">
<span class="slider-toggle"></span>
</label>
</div>
<span class="hint">Offloads heavy similarity calculations to a background worker to prevent UI lag.</span>
</div>
<div class="card">
<span class="field-label">Linguistic Intent Mapper</span>
<div id="intent-neotherion-container" style="max-height: 200px; overflow-y: auto; margin-bottom: 12px;"></div>
<button onclick="createIntentRow()" class="btn btn-outline" style="height: 38px; font-size: 11px;">+ MAP NEW INTENT</button>
</div>
<div class="card">
<div class="toggle-row">
<span class="field-label" style="margin:0;">Neural Auto-Teach</span>
<label class="switch">
<input type="checkbox" id="auto-teach-toggle" onchange="toggleAutoTeach()">
<span class="slider-toggle"></span>
</label>
</div>
</div>
<div class="card">
<div class="toggle-row">
<span class="field-label" style="margin:0;">Visualize Transitions</span>
<label class="switch">
<input type="checkbox" id="show-transitions-toggle" onchange="toggleTransitions()">
<span class="slider-toggle"></span>
</label>
</div>
</div>
<div class="card">
<span class="field-label">Dream Intensity (Markov Entropy)</span>
<div class="range-wrap">
<div style="display:flex; justify-content: space-between; font-size: 10px; color: var(--dream); margin-bottom: 8px;">
<span>COHERENT</span>
<span id="dream-intensity-val">Intensity: 30</span>
<span>CHAOTIC</span>
</div>
<input type="range" id="dream-intensity-slider" min="10" max="80" value="30" oninput="updateIntensity(this.value)">
</div>
</div>
<div class="card">
<span class="field-label">Persistent Variable Matrix</span>
<div id="variable-neotherion-container" style="max-height: 200px; overflow-y: auto; margin-bottom: 12px;"></div>
<button onclick="createVariableRow()" class="btn btn-outline" style="height: 38px; font-size: 11px;">+ REGISTER NEW VARIABLE</button>
</div>
<div class="card">
<span class="field-label">State Hierarchist</span>
<input id="new-status-name" class="multi-line" style="height:45px;" placeholder="State Name (e.g. Hostile)...">
<select id="new-status-parent" class="input-field"></select>
<button onclick="addStatus()" class="btn" style="margin:0;">REGISTER STATE</button>
<div id="state-list-container" style="margin-top:18px; max-height: 300px; overflow-y: auto; padding-right: 5px;"></div>
</div>
<div class="card">
<span class="field-label">Memory & Extraction</span>
<div class="toggle-row">
<span class="field-label" style="margin:0;">Include Temporal History</span>
<label class="switch">
<input type="checkbox" id="export-history-toggle">
<span class="slider-toggle"></span>
</label>
</div>
<button onclick="exportDB()" class="btn btn-outline" style="margin-top: 10px;">COPY NEURAL BACKUP</button>
<button onclick="importDB()" class="btn btn-outline" style="margin-top: 10px;">RESTORE FROM BACKUP</button>
<button onclick="wipeData()" class="btn btn-danger" style="margin-top: 10px;">PURGE ALL DATA</button>
</div>
</div>
<div id="tab-debug" class="tab-content">
<div class="card">
<span class="field-label">Real-time State Analysis</span>
<div style="padding: 15px; background: #000; border-radius: 8px; margin-bottom: 15px; border: 1px solid var(--border);">
<div style="font-size: 12px; margin-bottom: 10px; font-family: monospace;">
<strong style="color: var(--accent);">Active State:</strong> <span id="debug-current-state">-</span>
</div>
<div style="font-size: 12px; margin-bottom: 10px; font-family: monospace;">
<strong style="color: var(--accent);">Ancestry:</strong> <span id="debug-hierarchy">-</span>
</div>
<div style="font-size: 12px; font-family: monospace;">
<strong style="color: var(--accent);">Rule Availability:</strong> <span id="debug-rule-count">-</span>
</div>
</div>
<button onclick="testStateLogic()" class="btn btn-outline">VALIDATE FILTER LOGIC</button>
</div>
<div class="card">
<span class="field-label">Last Heuristic Trace</span>
<div id="debug-output" class="debug-panel">
<div class="debug-line">System idle... Awaiting input trace...</div>
</div>
</div>
<div class="card">
<span class="field-label">Confidence Sensitivity</span>
<div style="margin-bottom: 15px;">
<label style="font-size: 11px; display: block; margin-bottom: 6px; color: var(--subtext);">Regex Priority Threshold: <span id="regex-threshold-val">1.0</span></label>
<input type="range" min="0.95" max="1.0" step="0.01" value="1.0" id="regex-threshold" oninput="updateThreshold('regex', this.value)">
</div>
<div style="margin-bottom: 15px;">
<label style="font-size: 11px; display: block; margin-bottom: 6px; color: var(--subtext);">Vector Semantic Threshold: <span id="vector-threshold-val">0.75</span></label>
<input type="range" min="0.5" max="0.95" step="0.05" value="0.75" id="vector-threshold" oninput="updateThreshold('vector', this.value)">
</div>
<div>
<label style="font-size: 11px; display: block; margin-bottom: 6px; color: var(--subtext);">Fuzzy Levenshtein Threshold: <span id="fuzzy-threshold-val">0.65</span></label>
<input type="range" min="0.4" max="0.85" step="0.05" value="0.65" id="fuzzy-threshold" oninput="updateThreshold('fuzzy', this.value)">
</div>
</div>
</div>
</section>
<script type="module">
import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.14.0';
env.allowLocalModels = true;
env.allowRemoteModels = true;
env.localModelPath = 'models/';
let embeddingPipe = null;
let vectorWorker = null;
let vectorThreadingEnabled = false;
const db = new Dexie("NeoTherion");
db.version(5).stores({
rules: '++id, *triggers, *requiredStates, chainPrompt',
history: '++id, role, timestamp, ruleId, vector',
config: 'key',
variables: 'key',
intents: '++id, label, pattern'
}).upgrade(tx => {});
const workerCode = `
self.onmessage = function(e) {
const { type, uVector, rules } = e.data;
if (type === 'search') {
const results = rules.map(rule => {
if (!rule.vector || !uVector) return { id: rule.id, score: 0 };
let dot = 0, mA = 0, mB = 0;
for (let i = 0; i < uVector.length; i++) {
dot += uVector[i] * rule.vector[i];
mA += uVector[i] * uVector[i];
mB += rule.vector[i] * rule.vector[i];
}
const denom = Math.sqrt(mA) * Math.sqrt(mB);
return { id: rule.id, score: denom === 0 ? 0 : dot / denom };
});
self.postMessage(results);
}
};
`;
const blob = new Blob([workerCode], { type: 'application/javascript' });
vectorWorker = new Worker(URL.createObjectURL(blob));
const executeScripts = (element) => {
element.querySelectorAll("script").forEach(oldScript => {
const newScript = document.createElement("script");
Array.from(oldScript.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value));
newScript.appendChild(document.createTextNode(oldScript.innerHTML));
oldScript.parentNode.replaceChild(newScript, oldScript);
});
};
async function initNeuralCore() {
if (!embeddingPipe) {
const loaderMsg = document.getElementById('loader-msg');
if (loaderMsg) loaderMsg.textContent = "CHECKING LOCAL NEURAL CACHE...";
try {
embeddingPipe = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2', {
progress_callback: (p) => {
if (p.status === 'initiate' && loaderMsg) loaderMsg.textContent = "SYNCING REMOTE LAYERS (~30MB)...";
if (p.status === 'progress' && loaderMsg) loaderMsg.textContent = "DOWNLOADING: " + p.progress.toFixed(1) + "%";
}
});
if (loaderMsg) loaderMsg.textContent = "NEURAL SYNC COMPLETE ‚úì";
} catch (e) {
if (loaderMsg) loaderMsg.textContent = "OFFLINE MODE ACTIVE";
}
const loader = document.getElementById('system-loader');
if (loader) {
loader.style.opacity = '0';
setTimeout(() => loader.style.display = 'none', 1200);
}
}
}
async function getVector(text) {
if (!embeddingPipe) await initNeuralCore();
if (!text || !text.trim()) return null;
try {
const result = await embeddingPipe(text, { pooling: 'mean', normalize: true });
return Array.from(result.data);
} catch (e) { 
return null; 
}
}
async function getAverageVector(texts) {
const validTexts = texts.filter(t => t && t.trim());
if (validTexts.length === 0) return null;
if (validTexts.length === 1) return await getVector(validTexts[0]);
const vectors = (await Promise.all(validTexts.map(getVector))).filter(v => v !== null);
if (vectors.length === 0) return null;
const dim = vectors[0].length;
const avg = new Array(dim).fill(0);
for (const vec of vectors) {
for (let i = 0; i < dim; i++) avg[i] += vec[i];
}
const mag = Math.sqrt(avg.reduce((sum, val) => sum + val * val, 0));
if (mag > 0) { 
for (let i = 0; i < dim; i++) avg[i] /= mag; 
}
return avg;
}
function cosineSimilarity(a, b) {
if (!a || !b || a.length !== b.length) return 0;
let dot = 0, mA = 0, mB = 0;
for (let i = 0; i < a.length; i++) {
dot += a[i] * b[i];
mA += a[i] * a[i];
mB += b[i] * b[i];
}
const denom = Math.sqrt(mA) * Math.sqrt(mB);
return denom === 0 ? 0 : dot / denom;
}
async function preloadVectors() {
if (!embeddingPipe) await initNeuralCore();
const rulesToUpdate = await db.rules.filter(r => (!r.vector) && r.triggers && r.triggers.length > 0).toArray();
if (rulesToUpdate.length > 0) {
const statusEl = document.getElementById('preload-status');
if (statusEl) { statusEl.style.display = 'block'; statusEl.textContent = `VECTORS SYNCING...`; }
for (let i = 0; i < rulesToUpdate.length; i++) {
const rule = rulesToUpdate[i];
if (statusEl) statusEl.textContent = `SYNCING: ${i + 1}/${rulesToUpdate.length}`;
const vec = await getAverageVector(rule.triggers);
if (vec) await db.rules.update(rule.id, { vector: vec });
}
if (statusEl) { 
statusEl.textContent = 'NEURAL SYNCED'; 
setTimeout(() => { statusEl.style.display = 'none'; }, 2000); 
}
}
}
const MAINTAIN = "[Maintain State]";
let currentStatus = "Neutral";
let autoTeachEnabled = true;
let showTransitions = true;
let allowScripts = false; 
let dreamIntensity = 30;
let thresholds = { regex: 1.0, vector: 0.75, fuzzy: 0.65 };
let editingRuleId = null;
async function getRelevantHistory(queryVector, limit = 5) {
if (!queryVector) return [];
const history = await db.history.where('role').equals('user').reverse().limit(300).toArray();
const scored = history.filter(h => h.vector).map(h => ({ text: h.text, score: cosineSimilarity(queryVector, h.vector) })).filter(h => h.score > 0.6).sort((a, b) => b.score - a.score).slice(0, limit);
return scored.map(s => s.text);
}
async function processWithNLP(input) {
const doc = nlp(input);
let intent = 'unknown';
const mappedIntents = await db.intents.toArray();
for (const item of mappedIntents) {
try { 
if (doc.match(item.pattern).found) { 
intent = item.label; 
break; 
} 
} catch(e) {}
}
const entities = {};
const nameMatch = doc.people().first().text();
if (nameMatch) entities.user = nameMatch;
const normalizedText = doc.normalize({ whitespace: true, punctuation: true, case: true, contractions: true }).out('text');
return { intent, entities, normalizedText };
}
const NeoTherion = {
async getStatus() {
const cfg = await db.config.get('currentStatus');
const all = await this.getAllStatuses();
if (cfg && all.find(s => s.name === cfg.value)) return cfg.value;
return all.length > 0 ? all[0].name : "Neutral";
},
async setStatus(val) {
const all = await this.getAllStatuses();
if (!all.find(s => s.name === val)) val = all[0]?.name || "Neutral";
const oldStatus = currentStatus;
currentStatus = val;
await db.config.put({key: 'currentStatus', value: val});
const disp = document.getElementById('mode-display');
if (disp) disp.innerText = val;
return { oldStatus, newStatus: val };
},
async getAllStatuses() {
const cfg = await db.config.get('allStatuses');
return cfg ? cfg.value : [{name: 'Positive', parent: null}, {name: 'Neutral', parent: null}, {name: 'Negative', parent: null}];
},
async getStateHierarchy(stateName) {
const all = await this.getAllStatuses();
const hierarchy = [stateName];
let current = all.find(s => s.name === stateName);
let visited = new Set([stateName]);
while (current && current.parent) {
if (visited.has(current.parent)) break;
visited.add(current.parent);
current = all.find(s => s.name === current.parent);
if (current) hierarchy.unshift(current.name);
}
return hierarchy;
},
getLevenshtein(a, b) {
const matrix = Array.from({ length: a.length + 1 }, () => []);
for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
for (let j = 0; j <= b.length; j++) matrix[0][j] = j;
for (let i = 1; i <= a.length; i++) {
for (let j = 1; j <= b.length; j++) {
const cost = a[i - 1] === b[j - 1] ? 0 : 1;
matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost);
}
}
return matrix[a.length][b.length];
},
async findResponse(uText, uVector = null) {
const allRules = await db.rules.toArray();
const lastEntry = (await db.history.orderBy('id').reverse().limit(1).toArray())[0];
const currentHierarchy = await this.getStateHierarchy(currentStatus);
let best = null, topScore = 0, captures = {};
let matchMethod = 'none';
let debugLog = [];
let vectorScores = [];
if (vectorThreadingEnabled && uVector) {
debugLog.push("‚öô Background Vector calculation started...");
vectorScores = await new Promise(resolve => {
vectorWorker.onmessage = e => resolve(e.data);
vectorWorker.postMessage({ type: 'search', uVector, rules: allRules });
});
}
for (const rule of allRules) {
let trace = `Rule MOD_${rule.id}: `;
if (rule.requiredStates && rule.requiredStates.length > 0) {
const stateMatch = rule.requiredStates.some(req => currentHierarchy.includes(req));
if (!stateMatch) {
debugLog.push(`<div class="debug-line fail">‚äò MOD_${rule.id} rejected (State Path Mismatch)</div>`);
continue;
}
}
let ruleMaxScore = 0;
let ruleCaptures = {};
let ruleMethod = 'none';
for (let pattern of rule.triggers || []) {
let isRelational = pattern.startsWith('+');
let cleanPattern = isRelational ? pattern.substring(1).trim() : pattern;
const regexPattern = cleanPattern.replace(/\[(\w+)\]/g, '(.+)');
const regex = new RegExp(`^${regexPattern}$`, 'i');
const match = uText.match(regex);
if (match) {
ruleMaxScore = thresholds.regex; ruleMethod = 'regex';
const keys = [...cleanPattern.matchAll(/\[(\w+)\]/g)].map(m => m[1]);
keys.forEach((key, i) => ruleCaptures[key] = match[i + 1]);
if (isRelational && lastEntry) ruleMaxScore += 0.15;
break; 
}
}
if (ruleMaxScore >= thresholds.regex) {
if (ruleMaxScore > topScore) { 
topScore = ruleMaxScore; best = rule; captures = ruleCaptures; matchMethod = ruleMethod; 
}
debugLog.push(`<div class="debug-line">‚úì MOD_${rule.id} Regex Match Valid.</div>`);
continue; 
}
if (rule.vector) {
const threadScore = vectorScores.find(s => s.id === rule.id)?.score;
const semanticScore = threadScore !== undefined ? threadScore : (uVector ? cosineSimilarity(uVector, rule.vector) : 0);
if (semanticScore > ruleMaxScore) { 
ruleMaxScore = semanticScore; ruleMethod = 'vector'; 
}
}
if (ruleMaxScore >= thresholds.vector) {
if (ruleMaxScore > topScore) { 
topScore = ruleMaxScore; best = rule; captures = ruleCaptures; matchMethod = ruleMethod; 
}
debugLog.push(`<div class="debug-line">‚úì MOD_${rule.id} Vector Similarity: ${ruleMaxScore.toFixed(2)}</div>`);
continue; 
}
for (let pattern of rule.triggers || []) {
let isRelational = pattern.startsWith('+');
let cleanPattern = isRelational ? pattern.substring(1).trim() : pattern;
cleanPattern = cleanPattern.replace(/\[(\w+)\]/g, '');
if (uText.length && cleanPattern.length) {
const dist = this.getLevenshtein(uText.toLowerCase(), cleanPattern.toLowerCase());
const fuzzyScore = 1 - (dist / Math.max(uText.length, cleanPattern.length));
if (fuzzyScore > ruleMaxScore) { 
ruleMaxScore = fuzzyScore; ruleMethod = 'fuzzy'; 
}
}
}
if (ruleMaxScore > topScore) { 
topScore = ruleMaxScore; best = rule; captures = ruleCaptures; matchMethod = ruleMethod; 
}
if (ruleMaxScore > 0.4) {
debugLog.push(`<div class="debug-line path">? MOD_${rule.id} Low Confidence: ${ruleMaxScore.toFixed(2)} [${ruleMethod}]</div>`);
}
}
const debugOutput = document.getElementById('debug-output');
if (debugOutput) {
debugOutput.innerHTML = debugLog.join('');
}
const threshold = matchMethod === 'regex' ? thresholds.regex : matchMethod === 'vector' ? thresholds.vector : thresholds.fuzzy;
if (topScore >= threshold) {
for (let key in captures) { await db.variables.put({key, value: captures[key]}); }
const confidenceEl = document.getElementById('last-confidence');
if (confidenceEl) { 
confidenceEl.textContent = `${matchMethod.toUpperCase()} ${(topScore * 100).toFixed(0)}%`; 
}
return { rule: best, confidence: topScore, method: matchMethod };
}
return null;
},
async dream(seedText, queryVector = null) {
const recentHistory = await db.history.orderBy('id').reverse().limit(50).toArray();
const relevantTexts = queryVector ? await getRelevantHistory(queryVector, 5) : [];
const textChunks = [...recentHistory.map(h => h.text), ...relevantTexts].filter(t => t && t.length > 5);
if (textChunks.length < 5) return "The void is silent... speak more to awake me.";
const fullText = textChunks.join(' ');
const words = fullText.split(/\s+/).filter(w => w.length > 2);
if (words.length < 15) return "Neural pathways insufficient for dreaming.";
const trigrams = {};
for (let i = 0; i < words.length - 2; i++) {
const key = `${words[i].toLowerCase()} ${words[i + 1].toLowerCase()}`;
const next = words[i + 2];
if (!trigrams[key]) trigrams[key] = [];
trigrams[key].push(next);
}
const seedWords = seedText.toLowerCase().split(/\s+/).filter(w => w.length > 2);
let current = '';
for (let i = 0; i < seedWords.length - 1; i++) {
const testKey = `${seedWords[i]} ${seedWords[i + 1]}`;
if (trigrams[testKey]) { 
current = testKey; 
break; 
}
}
if (!current) { 
const keys = Object.keys(trigrams); 
current = keys[Math.floor(Math.random() * keys.length)]; 
}
if (!current) return "Echoes of the machine...";
let output = current.split(' ');
let attempts = 0;
const maxAttempts = dreamIntensity * 2;
while (output.length < dreamIntensity && attempts < maxAttempts) {
attempts++;
const options = trigrams[current];
if (!options || options.length === 0) { 
const keys = Object.keys(trigrams); 
current = keys[Math.floor(Math.random() * keys.length)]; 
continue; 
}
const next = options[Math.floor(Math.random() * options.length)];
output.push(next);
const parts = current.split(' ');
current = `${parts[1]} ${next.toLowerCase()}`;
if (next.match(/[.!?]$/) && output.length > 10 && Math.random() < 0.3) break;
}
let result = output.join(' ');
if (result.length > 0) result = result.charAt(0).toUpperCase() + result.slice(1);
if (result.length > 0 && !result.match(/[.!?]$/)) result += '...';
return result;
},
async inject(text) {
const d = new Date();
let out = text.replace(/\(status\)/gi, currentStatus).replace(/\(time\)/gi, d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })).replace(/\(day\)/gi, new Intl.DateTimeFormat('en-US', { weekday: 'long' }).format(d));
const variablesCache = {};
const vars = await db.variables.toArray();
vars.forEach(v => { variablesCache[v.key] = v.value; });
out = out.replace(/\(([a-zA-Z0-9_]+)\|([^)]+)\)/g, (match, key, fallback) => { return variablesCache.hasOwnProperty(key) ? variablesCache[key] : fallback; });
out = out.replace(/\(([a-zA-Z0-9_]+)\)/g, (match, key) => { return variablesCache.hasOwnProperty(key) ? variablesCache[key] : match; });
out = out.replace(/\(([A-Z][a-zA-Z0-9_]*)\)/g, (match, key) => { const lowerKey = key.charAt(0).toLowerCase() + key.slice(1); const val = variablesCache[lowerKey]; return val ? val.charAt(0).toUpperCase() + val.slice(1) : match; });
return out;
},
chooseWeighted(items) {
if (!items || items.length === 0) return "";
const pool = [];
for (const item of items) {
const w = parseInt(item.weight) || 1;
for (let i = 0; i < w; i++) pool.push(item.text);
}
return pool.length > 0 ? pool[Math.floor(Math.random() * pool.length)] : items[0]?.text || "";
}
};
window.updateIntensity = async function(val) { 
dreamIntensity = parseInt(val); 
document.getElementById('dream-intensity-val').innerText = `Intensity: ${val}`; 
await db.config.put({key: 'dreamIntensity', value: dreamIntensity}); 
};
window.updateThreshold = async function(type, val) { 
thresholds[type] = parseFloat(val); 
document.getElementById(`${type}-threshold-val`).innerText = val; 
await db.config.put({key: 'thresholds', value: thresholds}); 
};
window.toggleTransitions = async function() { 
showTransitions = document.getElementById('show-transitions-toggle').checked; 
await db.config.put({key: 'showTransitions', value: showTransitions}); 
};
window.toggleScriptExecution = async function() { 
allowScripts = document.getElementById('script-exec-toggle').checked; 
await db.config.put({key: 'allowScripts', value: allowScripts}); 
};
window.toggleVectorThreading = async function() { 
vectorThreadingEnabled = document.getElementById('vector-threading-toggle').checked; 
await db.config.put({key: 'vectorThreading', value: vectorThreadingEnabled}); 
};
window.updateResponsePreview = async function() {
const items = document.querySelectorAll('#response-grid .response-item');
if (items.length === 0) { 
document.getElementById('response-preview').textContent = 'Awaiting neural input...'; 
return; 
}
const firstResponse = items[0].querySelector('.response-text')?.value || '';
if (!firstResponse.trim()) { 
document.getElementById('response-preview').textContent = 'Awaiting neural input...'; 
return; 
}
const injected = await NeoTherion.inject(firstResponse);
document.getElementById('response-preview').innerHTML = marked.parse(injected);
};
window.addResponseItem = function(text = '', weight = 1) {
const grid = document.getElementById('response-grid');
const item = document.createElement('div');
item.className = 'check-item response-item';
item.innerHTML = `
<textarea class="multi-line response-text" placeholder="Beast response text..." oninput="updateResponsePreview()">${text}</textarea>
<input type="number" class="weight-input" value="${weight}" min="1">
<button onclick="this.parentElement.remove(); updateResponsePreview();" style="background:none; border:none; color:var(--err); font-size:22px; margin-left:10px; cursor:pointer;">√ó</button>
`;
grid.appendChild(item);
updateResponsePreview();
};
window.handleSend = async function(customInput = null) {
const el = document.getElementById('user-input');
const rawInput = customInput || el.value.trim();
if (!rawInput) return;
if (!customInput) { 
el.value = ""; el.style.height = 'auto'; 
}
const nlpResult = await processWithNLP(rawInput);
for (let key in nlpResult.entities) { 
await db.variables.put({ key, value: nlpResult.entities[key] }); 
}
const userVec = await getVector(nlpResult.normalizedText);
await appendChat('user', rawInput, null, null, null, null, null, userVec);
const chatWin = document.getElementById('chat-window');
const typing = document.createElement('div');
typing.className = 'typing-bubble';
typing.id = 'typing-indicator';
typing.innerHTML = '<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>';
chatWin.appendChild(typing);
chatWin.scrollTop = chatWin.scrollHeight;
const matchResult = await NeoTherion.findResponse(nlpResult.normalizedText, userVec);
setTimeout(async () => {
const indicator = document.getElementById('typing-indicator');
if (indicator) indicator.remove();
if (matchResult && matchResult.rule) {
const match = matchResult.rule;
let responseText = Array.isArray(match.responses) ? NeoTherion.chooseWeighted(match.responses) : match.responses;
const injected = await NeoTherion.inject(responseText);
let nextStatus = currentStatus;
if (match.stateWeights && !match.stateWeights[MAINTAIN]) {
const pool = [];
for (let sName in match.stateWeights) { 
const w = parseInt(match.stateWeights[sName]) || 1; 
for (let i = 0; i < w; i++) pool.push(sName); 
}
if (pool.length > 0) nextStatus = pool[Math.floor(Math.random() * pool.length)];
}
const transition = await NeoTherion.setStatus(nextStatus);
await appendChat('bot', injected, currentStatus, match.id, matchResult.confidence, matchResult.method, transition);
if (match.chainPrompt) { 
setTimeout(() => handleSend(match.chainPrompt), 1500); 
}
} else {
const dreamText = await NeoTherion.dream(rawInput, userVec);
await appendChat('bot', dreamText, "Dreaming", null, 0, 'dream');
if (autoTeachEnabled) await appendTeachPrompt(rawInput);
}
}, 800);
};
async function appendChat(role, text, status = null, ruleId = null, confidence = null, method = null, transition = null, vector = null) {
const win = document.getElementById('chat-window');
const now = Date.now();
const dateStr = new Date(now).toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' });
const lastMsg = await db.history.orderBy('id').reverse().limit(1).first();
let lastDateStr = null;
if (lastMsg) lastDateStr = new Date(lastMsg.timestamp).toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' });
if (!lastDateStr || dateStr !== lastDateStr) {
const sep = document.createElement('div'); sep.className = 'date-separator'; sep.textContent = dateStr; win.appendChild(sep);
}
const b = document.createElement('div'); 
b.className = "bubble " + role;
if (status && role === 'bot') {
b.setAttribute('data-state', status);
const tag = document.createElement('span'); 
tag.className = 'state-tag'; tag.textContent = status; 
b.appendChild(tag);
if (confidence !== null && method) {
const badge = document.createElement('span'); badge.className = 'confidence-badge'; badge.textContent = method.toUpperCase() + " " + (confidence * 100).toFixed(0) + "%"; 
b.appendChild(badge);
}
}
const msg = document.createElement('span');
msg.className = 'message-text';
msg.innerHTML = (role === 'bot') ? marked.parse(text) : text;
b.appendChild(msg);
if (showTransitions && transition && transition.oldStatus !== transition.newStatus && role === 'bot') {
const transDiv = document.createElement('div'); transDiv.className = 'state-transition'; transDiv.textContent = transition.oldStatus + " ‚Üí " + transition.newStatus; b.appendChild(transDiv);
}
win.appendChild(b);
if (allowScripts) executeScripts(msg);
win.scrollTop = win.scrollHeight;
await db.history.add({ role, text, status, timestamp: now, ruleId, vector });
}
async function appendTeachPrompt(userInput) {
const win = document.getElementById('chat-window');
const prompt = document.createElement('div');
prompt.className = 'teach-prompt';
const escapedInput = userInput.replace(/'/g, "\\'");
prompt.innerHTML = `Pattern Unrecognized. Incorporate into neural core? <br><br> <button onclick="openTeachMode('${escapedInput}')">TRAIN</button> <button id="quick-enter-btn" onclick="quickCommit('${escapedInput}')">INSTANT LOG</button>`;
win.appendChild(prompt);
win.scrollTop = win.scrollHeight;
}
window.quickCommit = async function(trigger) {
const botBubbles = document.querySelectorAll('.bubble.bot');
const lastBubble = botBubbles[botBubbles.length - 1];
if (!lastBubble) return;
const contentSpan = lastBubble.querySelector('.message-text');
const responseText = contentSpan ? contentSpan.innerText : lastBubble.innerText;
const vector = await getAverageVector([trigger]);
await db.rules.add({ triggers: [trigger], responses: [{ weight: 1, text: responseText }], stateWeights: { "[Maintain State]": 1 }, requiredStates: [], vector });
updateUI();
};
window.openTeachMode = function(input) { 
document.getElementById('train-trigger').value = input; switchTab(null, 'tab-train'); openLab(); 
};
window.toggleAutoTeach = async function() { 
autoTeachEnabled = document.getElementById('auto-teach-toggle').checked; await db.config.put({key: 'autoTeach', value: autoTeachEnabled}); 
};
window.refreshVariableEditor = async function() {
const vars = await db.variables.toArray();
const container = document.getElementById('variable-neotherion-container');
if (container) { container.innerHTML = ''; vars.forEach(v => createVariableRow(v.key, v.value)); }
};
window.createVariableRow = function(key = '', value = '') {
const container = document.getElementById('variable-neotherion-container');
const row = document.createElement('div');
row.className = 'var-row'; row.style.cssText = 'display:flex; gap:10px; margin-bottom:10px;';
row.innerHTML = `<input type="text" class="multi-line" style="margin:0; flex:1; height:38px; padding:8px; font-size:12px;" placeholder="Key" value="${key}" onblur="updateVar(this, 'key', '${key}')"> <input type="text" class="multi-line" style="margin:0; flex:2; height:38px; padding:8px; font-size:12px;" placeholder="Value" value="${value}" onblur="updateVar(this, 'value', '${key}')"> <button onclick="deleteVar('${key}', this)" style="background:none; border:none; color:var(--err); cursor:pointer; font-size:22px;">√ó</button>`;
container.appendChild(row);
};
window.updateVar = async function(el, type, oldKey) {
const row = el.closest('.var-row');
const newKey = row.querySelector('input[placeholder="Key"]').value.trim();
const newVal = row.querySelector('input[placeholder="Value"]').value.trim();
if (type === 'key' && oldKey && oldKey !== newKey) await db.variables.delete(oldKey);
if (newKey) await db.variables.put({ key: newKey, value: newVal });
};
window.deleteVar = async function(key, el) { if (key) await db.variables.delete(key); el.closest('.var-row').remove(); };
window.refreshIntentList = async function() {
const intents = await db.intents.toArray();
const container = document.getElementById('intent-neotherion-container');
if (container) { container.innerHTML = ''; intents.forEach(i => createIntentRow(i.id, i.label, i.pattern)); }
};
window.createIntentRow = function(id = null, label = '', pattern = '') {
const container = document.getElementById('intent-neotherion-container');
const row = document.createElement('div');
row.className = 'intent-row'; row.style.cssText = 'display:flex; gap:10px; margin-bottom:10px;';
row.innerHTML = `<input type="text" class="multi-line" style="margin:0; flex:1; height:38px; padding:8px; font-size:12px;" placeholder="Label" value="${label}" onblur="updateIntent(this, ${id})"> <input type="text" class="multi-line" style="margin:0; flex:2; height:38px; padding:8px; font-size:12px;" placeholder="Pattern" value="${pattern}" onblur="updateIntent(this, ${id})"> <button onclick="deleteIntent(${id}, this)" style="background:none; border:none; color:var(--err); cursor:pointer; font-size:22px;">√ó</button>`;
container.appendChild(row);
};
window.updateIntent = async function(el, id) {
const row = el.closest('.intent-row');
const label = row.querySelector('input[placeholder^="Label"]').value.trim();
const pattern = row.querySelector('input[placeholder^="Pattern"]').value.trim();
if (label && pattern) { 
if (id) await db.intents.update(id, { label, pattern }); 
else await db.intents.add({ label, pattern }); 
refreshIntentList(); 
}
};
window.deleteIntent = async function(id, el) { 
if (id) await db.intents.delete(id); el.closest('.intent-row').remove(); 
};
window.loadRuleLibrary = async function() {
const rules = await db.rules.toArray();
const listEl = document.getElementById('rule-list');
const countEl = document.getElementById('rule-count');
if (countEl) countEl.textContent = rules.length;
if (!listEl) return; listEl.innerHTML = '';
for (const rule of rules) {
const card = document.createElement('div'); card.className = 'rule-card';
card.innerHTML = `<div class="rule-header"><span class="rule-id">MOD_${rule.id}</span> <div class="rule-actions"> <button class="rule-action-btn" onclick="editRule(${rule.id})">EDIT</button> <button class="rule-action-btn delete" onclick="deleteRule(${rule.id})">REMOVE</button> </div> </div> <div class="rule-detail"><strong>Inputs:</strong> ${rule.triggers?.join(', ')}</div>`;
listEl.appendChild(card);
}
};
window.editRule = async function(ruleId) {
const rule = await db.rules.get(ruleId);
if (!rule) return;
editingRuleId = ruleId;
document.getElementById('train-trigger').value = rule.triggers?.join('\n') || '';
document.getElementById('train-chain').value = rule.chainPrompt || '';
document.getElementById('response-grid').innerHTML = '';
if (rule.responses) rule.responses.forEach(r => addResponseItem(r.text, r.weight));
document.querySelectorAll('#next-state-grid .status-checkbox').forEach(cb => { cb.checked = rule.stateWeights && rule.stateWeights[cb.value]; });
document.querySelectorAll('#filter-state-grid .status-checkbox').forEach(cb => { cb.checked = rule.requiredStates && rule.requiredStates.includes(cb.value); });
syncSubStates(); switchTab(null, 'tab-train'); openLab();
};
window.deleteRule = async function(ruleId) { if (!confirm(`Delete Rule #${ruleId}?`)) return; await db.rules.delete(ruleId); await loadRuleLibrary(); };
window.updateUI = async function() {
currentStatus = await NeoTherion.getStatus();
const modeDisp = document.getElementById('mode-display'); if (modeDisp) modeDisp.innerText = currentStatus;
const teachCfg = await db.config.get('autoTeach'); autoTeachEnabled = teachCfg ? teachCfg.value : true; document.getElementById('auto-teach-toggle').checked = autoTeachEnabled;
const transCfg = await db.config.get('showTransitions'); showTransitions = transCfg ? transCfg.value : true; document.getElementById('show-transitions-toggle').checked = showTransitions;
const scriptCfg = await db.config.get('allowScripts'); allowScripts = scriptCfg ? scriptCfg.value : false; document.getElementById('script-exec-toggle').checked = allowScripts;
const threadCfg = await db.config.get('vectorThreading'); vectorThreadingEnabled = threadCfg ? threadCfg.value : false; document.getElementById('vector-threading-toggle').checked = vectorThreadingEnabled;
const intensityCfg = await db.config.get('dreamIntensity'); dreamIntensity = intensityCfg ? intensityCfg.value : 30; document.getElementById('dream-intensity-slider').value = dreamIntensity;
const thresholdCfg = await db.config.get('thresholds'); if (thresholdCfg) thresholds = thresholdCfg.value;
const statuses = await NeoTherion.getAllStatuses(); const parents = statuses.filter(s => !s.parent);
const listContainer = document.getElementById('state-list-container'); const parentSelect = document.getElementById('new-status-parent');
listContainer.innerHTML = ""; parentSelect.innerHTML = `<option value="">TOP-LEVEL</option>`;
parents.forEach(p => {
listContainer.innerHTML += `<div class="state-item"><span>${p.name}</span><button onclick="deleteStatus('${p.name}')">√ó</button></div>`;
parentSelect.innerHTML += `<option value="${p.name}">${p.name}</option>`;
statuses.filter(s => s.parent === p.name).forEach(c => { listContainer.innerHTML += `<div class="state-item sub-item"><span>‚Ü≥ ${c.name}</span><button onclick="deleteStatus('${c.name}')">√ó</button></div>`; });
});
const prepareGrid = (gridId, includeWeight = false) => {
const grid = document.getElementById(gridId); if (!grid) return; grid.innerHTML = '';
if (gridId === 'next-state-grid') grid.innerHTML += `<label class="check-item"><input type="checkbox" class="status-checkbox" value="${MAINTAIN}"> <span>${MAINTAIN}</span></label>`;
parents.forEach(p => { grid.innerHTML += `<label class="check-item"><input type="checkbox" class="status-checkbox" value="${p.name}" onchange="syncSubStates(this)"> <span>${p.name}</span>${includeWeight ? '<input type="number" class="weight-input" value="10" min="1">' : ''}</label>`; statuses.filter(s => s.parent === p.name).forEach(c => { grid.innerHTML += `<label class="check-item sub" data-parent="${c.parent}"><input type="checkbox" class="status-checkbox" value="${c.name}" onchange="syncSubStates(this)"> <span>${c.name}</span>${includeWeight ? '<input type="number" class="weight-input" value="10" min="1">' : ''}</label>`; }); });
};
prepareGrid('next-state-grid', true); prepareGrid('filter-state-grid', false); syncSubStates(); refreshVariableEditor(); refreshIntentList();
if (document.getElementById('response-grid').children.length === 0) addResponseItem();
await loadRuleLibrary();
};
window.syncSubStates = function(trigger) {
document.querySelectorAll('.checkbox-grid').forEach(grid => {
const checked = Array.from(grid.querySelectorAll('.status-checkbox:checked')).map(cb => cb.value);
grid.querySelectorAll('.check-item.sub').forEach(el => { const p = el.getAttribute('data-parent'); if (checked.includes(p)) el.classList.add('active'); else { el.classList.remove('active'); const cb = el.querySelector('input'); if (cb) cb.checked = false; } });
});
};
window.addStatus = async function() {
const name = document.getElementById('new-status-name').value.trim();
const parent = document.getElementById('new-status-parent').value;
if (name) { 
const list = await NeoTherion.getAllStatuses(); 
if (!list.find(s => s.name === name)) { 
list.push({name, parent: parent || null}); 
await db.config.put({key: 'allStatuses', value: list}); 
updateUI(); 
} 
}
};
window.deleteStatus = async function(name) { 
if (!confirm(`Delete state ${name}?`)) return; 
let list = await NeoTherion.getAllStatuses(); 
list = list.filter(s => s.name !== name && s.parent !== name); 
await db.config.put({key: 'allStatuses', value: list}); updateUI(); 
};
window.saveTraining = async function() {
const triggers = document.getElementById('train-trigger').value.split('\n').filter(t => t.trim());
const chainPrompt = document.getElementById('train-chain').value.trim();
const stateWeights = {};
document.querySelectorAll('#next-state-grid .status-checkbox:checked').forEach(cb => { 
if (cb.value === MAINTAIN) stateWeights[MAINTAIN] = 1; 
else { 
const w = cb.parentElement.querySelector('.weight-input'); 
stateWeights[cb.value] = w ? parseInt(w.value) : 1; 
} 
});
const requiredStates = Array.from(document.querySelectorAll('#filter-state-grid .status-checkbox:checked')).map(cb => cb.value);
const responses = [];
document.querySelectorAll('#response-grid .response-item').forEach(item => { 
const text = item.querySelector('.response-text')?.value.trim(); 
const weight = parseInt(item.querySelector('.weight-input')?.value) || 1; 
if (text) responses.push({ weight, text }); 
});
const vector = await getAverageVector(triggers);
if (editingRuleId !== null) { 
await db.rules.update(editingRuleId, { triggers, responses, stateWeights, requiredStates, vector, chainPrompt }); editingRuleId = null; 
} else { 
await db.rules.add({ triggers, responses, stateWeights, requiredStates, vector, chainPrompt }); 
}
document.getElementById('train-trigger').value = ""; 
document.getElementById('train-chain').value = ""; 
document.getElementById('response-grid').innerHTML = ""; 
addResponseItem(); 
updateUI();
};
async function loadHistory() {
const history = await db.history.orderBy('timestamp').toArray();
const win = document.getElementById('chat-window'); win.innerHTML = "";
for (const h of history) {
const b = document.createElement('div'); b.className = "bubble " + h.role;
if (h.status && h.role === 'bot') { 
b.setAttribute('data-state', h.status); 
const tag = document.createElement('span'); tag.className = 'state-tag'; tag.textContent = h.status; b.appendChild(tag); 
}
const msg = document.createElement('span'); 
msg.className = 'message-text';
msg.innerHTML = (h.role === 'bot') ? marked.parse(h.text) : h.text; b.appendChild(msg); win.appendChild(b);
if (allowScripts) executeScripts(msg);
}
win.scrollTop = win.scrollHeight;
}
window.toggleLab = function() { 
const l = document.getElementById('lab'); 
l.style.display = (l.style.display === 'flex') ? 'none' : 'flex'; 
};
window.openLab = function() { 
document.getElementById('lab').style.display = 'flex'; 
};
window.switchTab = function(e, id) { 
document.querySelectorAll('.tab-content, .tab-btn').forEach(el => el.classList.remove('active')); 
document.getElementById(id).classList.add('active'); 
if(e) e.target.classList.add('active'); 
};
window.exportDB = async function() {
const data = { 
rules: await db.rules.toArray(), 
config: await db.config.toArray(), 
variables: await db.variables.toArray(), 
intents: await db.intents.toArray(), 
history: document.getElementById('export-history-toggle').checked ? await db.history.toArray() : [] 
};
navigator.clipboard.writeText(JSON.stringify(data)); 
alert("Backup copied.");
};
window.importDB = async function() {
const raw = prompt("Paste backup:"); 
if (!raw) return;
try {
const d = JSON.parse(raw);
if (d.rules) { await db.rules.clear(); await db.rules.bulkPut(d.rules); }
location.reload();
} catch (e) { alert("Fail"); }
};
window.parseUniversal = async function() {
const raw = document.getElementById('bulk-input').value.trim(); 
if (!raw) return;
try { 
const data = JSON.parse(raw); 
if (data.rules) await db.rules.bulkPut(data.rules); 
location.reload(); 
} catch (e) {}
};
window.wipeData = async function() { 
if(!confirm("Purge?")) return; 
await db.delete(); location.reload(); 
};
window.testStateLogic = async function() {
const hierarchy = await NeoTherion.getStateHierarchy(currentStatus);
const allRules = await db.rules.toArray();
const filtered = allRules.filter(rule => { 
if (!rule.requiredStates || rule.requiredStates.length === 0) return true; 
return rule.requiredStates.some(req => hierarchy.includes(req)); 
});
document.getElementById('debug-current-state').textContent = currentStatus;
document.getElementById('debug-hierarchy').textContent = hierarchy.join(' > ');
document.getElementById('debug-rule-count').textContent = filtered.length + " Rules in path";
alert(filtered.length + " rules available.");
};
window.onload = async () => {
await updateUI(); 
await loadHistory();
setTimeout(async () => { await initNeuralCore(); await preloadVectors(); }, 1000);
const inputEl = document.getElementById('user-input');
if (inputEl) {
inputEl.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } });
inputEl.addEventListener('input', function() { this.style.height = 'auto'; this.style.height = Math.min(this.scrollHeight, 150) + 'px'; });
}
const sendBtn = document.getElementById('send-btn'); 
if (sendBtn) sendBtn.addEventListener('click', () => handleSend());
};
window.toggleMessageVisibility = function() {
const bubbles = document.querySelectorAll('.bubble, .date-separator, .teach-prompt');
for (let i = 0; i < bubbles.length - 1; i++) { 
bubbles[i].classList.toggle('message-hidden'); 
}
};
window.NeoTherion = NeoTherion;
async function logHeuristic(msg, type = 'normal') {
const panel = document.getElementById('debug-output');
if (!panel) return;
const line = document.createElement('div');
line.className = 'debug-line ' + type;
line.textContent = "[" + new Date().toLocaleTimeString() + "] " + msg;
panel.appendChild(line);
panel.scrollTop = panel.scrollHeight;
}
</script>
<script>
window.handleSend = async function(customInput = null) {
const el = document.getElementById('user-input');
const rawInput = customInput || el.value.trim();
if (!rawInput) return;
if (!customInput) { el.value = ""; el.style.height = 'auto'; }
const nlpResult = await processWithNLP(rawInput);
for (let key in nlpResult.entities) { await db.variables.put({ key, value: nlpResult.entities[key] }); }
const userVec = await getVector(nlpResult.normalizedText);
await appendChat('user', rawInput, null, null, null, null, null, userVec);
const chatWin = document.getElementById('chat-window');
const typing = document.createElement('div');
typing.className = 'typing-bubble';
typing.id = 'typing-indicator';
typing.innerHTML = '<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>';
chatWin.appendChild(typing);
chatWin.scrollTop = chatWin.scrollHeight;
const debugPanel = document.getElementById('debug-output');
if (debugPanel) debugPanel.innerHTML = "";
const matchResult = await NeoTherion.findResponse(nlpResult.normalizedText, userVec);
setTimeout(async () => {
const indicator = document.getElementById('typing-indicator');
if (indicator) indicator.remove();
if (matchResult && matchResult.rule) {
const match = matchResult.rule;
let responseText = Array.isArray(match.responses) ? NeoTherion.chooseWeighted(match.responses) : match.responses;
const injected = await NeoTherion.inject(responseText);
let nextStatus = currentStatus;
if (match.stateWeights && !match.stateWeights[MAINTAIN]) {
const pool = [];
for (let sName in match.stateWeights) { 
const w = parseInt(match.stateWeights[sName]) || 1; 
for (let i = 0; i < w; i++) pool.push(sName); 
}
if (pool.length > 0) nextStatus = pool[Math.floor(Math.random() * pool.length)];
}
const transition = await NeoTherion.setStatus(nextStatus);
await appendChat('bot', injected, currentStatus, match.id, matchResult.confidence, matchResult.method, transition);
if (match.chainPrompt) { setTimeout(() => handleSend(match.chainPrompt), 1500); }
} else {
const dreamText = await NeoTherion.dream(rawInput, userVec);
await appendChat('bot', dreamText, "Dreaming", null, 0, 'dream');
if (autoTeachEnabled) await appendTeachPrompt(rawInput);
}
}, 800);
};
NeoTherion.findResponse = async function(uText, uVector = null) {
const allRules = await db.rules.toArray();
const lastEntry = (await db.history.orderBy('id').reverse().limit(1).toArray())[0];
const currentHierarchy = await NeoTherion.getStateHierarchy(currentStatus);
let best = null, topScore = 0, captures = {};
let matchMethod = 'none';
let debugLog = [];
let vectorScores = [];
logHeuristic("Heuristic Analysis Init: " + uText);
logHeuristic("Active State Path: " + currentHierarchy.join(' > '));
if (vectorThreadingEnabled && uVector) {
logHeuristic("Vector calculation offloaded to worker thread.");
vectorScores = await new Promise(resolve => {
vectorWorker.onmessage = e => resolve(e.data);
vectorWorker.postMessage({ type: 'search', uVector, rules: allRules });
});
}
for (const rule of allRules) {
if (rule.requiredStates && rule.requiredStates.length > 0) {
const stateMatch = rule.requiredStates.some(req => currentHierarchy.includes(req));
if (!stateMatch) {
logHeuristic("MOD_" + rule.id + " skipped: required states [" + rule.requiredStates.join(',') + "] missing from current path.", "fail");
continue;
}
}
let ruleMaxScore = 0;
let ruleCaptures = {};
let ruleMethod = 'none';
for (let pattern of rule.triggers || []) {
let isRelational = pattern.startsWith('+');
let cleanPattern = isRelational ? pattern.substring(1).trim() : pattern;
const regexPattern = cleanPattern.replace(/\[(\w+)\]/g, '(.+)');
const regex = new RegExp("^" + regexPattern + "$", 'i');
const match = uText.match(regex);
if (match) {
ruleMaxScore = thresholds.regex; ruleMethod = 'regex';
const keys = [...cleanPattern.matchAll(/\[(\w+)\]/g)].map(m => m[1]);
keys.forEach((key, i) => ruleCaptures[key] = match[i + 1]);
if (isRelational && lastEntry) ruleMaxScore += 0.15;
break; 
}
}
if (ruleMaxScore >= thresholds.regex) {
logHeuristic("MOD_" + rule.id + " matched via REGEX.", "normal");
if (ruleMaxScore > topScore) { topScore = ruleMaxScore; best = rule; captures = ruleCaptures; matchMethod = ruleMethod; }
continue; 
}
if (rule.vector) {
const threadScore = vectorScores.find(s => s.id === rule.id)?.score;
const semanticScore = threadScore !== undefined ? threadScore : (uVector ? cosineSimilarity(uVector, rule.vector) : 0);
if (semanticScore > ruleMaxScore) { ruleMaxScore = semanticScore; ruleMethod = 'vector'; }
}
if (ruleMaxScore >= thresholds.vector) {
logHeuristic("MOD_" + rule.id + " potential match via VECTOR: " + ruleMaxScore.toFixed(2), "normal");
if (ruleMaxScore > topScore) { topScore = ruleMaxScore; best = rule; captures = ruleCaptures; matchMethod = ruleMethod; }
continue; 
}
for (let pattern of rule.triggers || []) {
let isRelational = pattern.startsWith('+');
let cleanPattern = isRelational ? pattern.substring(1).trim() : pattern;
cleanPattern = cleanPattern.replace(/\[(\w+)\]/g, '');
if (uText.length && cleanPattern.length) {
const dist = this.getLevenshtein(uText.toLowerCase(), cleanPattern.toLowerCase());
const fuzzyScore = 1 - (dist / Math.max(uText.length, cleanPattern.length));
if (fuzzyScore > ruleMaxScore) { ruleMaxScore = fuzzyScore; ruleMethod = 'fuzzy'; }
}
}
if (ruleMaxScore > topScore) { 
logHeuristic("MOD_" + rule.id + " updated as top candidate via FUZZY: " + ruleMaxScore.toFixed(2));
topScore = ruleMaxScore; best = rule; captures = ruleCaptures; matchMethod = ruleMethod; 
}
}
const threshold = matchMethod === 'regex' ? thresholds.regex : matchMethod === 'vector' ? thresholds.vector : thresholds.fuzzy;
if (topScore >= threshold) {
logHeuristic("Neural Choice Confirmed: MOD_" + best.id + " Score: " + topScore.toFixed(2), "normal");
for (let key in captures) { await db.variables.put({key, value: captures[key]}); }
const confidenceEl = document.getElementById('last-confidence');
if (confidenceEl) { confidenceEl.textContent = matchMethod.toUpperCase() + " " + (topScore * 100).toFixed(0) + "%"; }
return { rule: best, confidence: topScore, method: matchMethod };
}
logHeuristic("No rule threshold reached. Confidence: " + topScore.toFixed(2), "fail");
return null;
};
</script>
</body>
</html>
